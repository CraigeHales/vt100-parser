#!/usr/bin/env python

import sys, os

EXT = '.html'


ATTRIBUTES  = 0xffff0000
BOLD        = 0x00010000
UNDERLINE   = 0x00020000
BLINK       = 0x00040000
INVERSE     = 0x00080000
FG_POS      = 20
FG_POS      = 24
FG          = 0xf << FG_POS
BG          = 0xf << BG_POS
BLACK       = 0
RED         = 1
GREEN       = 2
YELLOW      = 3
BLUE        = 4
MAGENTA     = 5
CYAN        = 6
WHITE       = 7
COLOR_SET   = 8
FG_BLACK    = (BLACK   | COLOR_SET) << FG_POS
FG_RED      = (RED     | COLOR_SET) << FG_POS
FG_GREEN    = (GREEN   | COLOR_SET) << FG_POS
FG_YELLOW   = (YELLOW  | COLOR_SET) << FG_POS
FG_BLUE     = (BLUE    | COLOR_SET) << FG_POS
FG_MAGENTA  = (MAGENTA | COLOR_SET) << FG_POS
FG_CYAN     = (CYAN    | COLOR_SET) << FG_POS
FG_WHITE    = (WHITE   | COLOR_SET) << FG_POS
BG_BLACK    = (BLACK   | COLOR_SET) << BG_POS
BG_RED      = (RED     | COLOR_SET) << BG_POS
BG_GREEN    = (GREEN   | COLOR_SET) << BG_POS
BG_YELLOW   = (YELLOW  | COLOR_SET) << BG_POS
BG_BLUE     = (BLUE    | COLOR_SET) << BG_POS
BG_MAGENTA  = (MAGENTA | COLOR_SET) << BG_POS
BG_CYAN     = (CYAN    | COLOR_SET) << BG_POS
BG_WHITE    = (WHITE   | COLOR_SET) << BG_POS


M_NORMAL, M_ESCAPE, IGNORE_TEXT, PM, APC, DCS, CSR, ACCEPT_CHAR = range(5)


class Terminal (object):
    def __init__(self):
        self.width = 80
        self.height = 24
        self.pos = [0,0]
        self.current_attributes = 0
        self.history = []
        self.screen = [[]]
        self.add = self.add_normal

    def move(self, down, right):
        self.pos[0] += max(-self.pos[0], down)
        self.pos[1] += max(-self.pos[1], right)
        if self.pos[0] > self.height:
            extra = self.pos[0] - self.height
            self.history.extend( self.screen[:extra] )
            del self.screen[:extra]

    def __setattr__(self, pos, value):
        r,c = pos
        if r >= len(self.screen):
            if r > self.height:
                self.history.extend( self.screen[]) # TODO


    NUL = None
    SOH = None
    STX = None
    ETX = None
    EOT = None
    ENQ = None
    ACK = None
    BEL = None
    BS  = None
    HT  = None
    LF  = None
    VT  = None
    FF  = None
    CR  = None
    SO  = None
    SI  = None

    DLE = None
    DC1 = None
    DC2 = None
    DC3 = None
    DC4 = None
    NAK = None
    SYN = None
    ETB = None
    CAN = None
    EM  = None
    SUB = None
    ESC = None
    FS  = None
    GS  = None
    RS  = None
    US  = None


    C0 = [
        "NUL",  #  0x00  ^@  '\0'
        "SOH",  #  0x01  ^A  start of heading
        "STX",  #  0x02  ^B  start of text
        "ETX",  #  0x03  ^C  end of text
        "EOT",  #  0x04  ^D  end of transmission
        "ENQ",  #  0x05  ^E  enquiry
        "ACK",  #  0x06  ^F  acknowledge
        "BEL",  #  0x07  ^G  '\a' bell
        "BS",   #  0x08  ^H  '\b' backspace
        "HT",   #  0x09  ^I  '\t' horizontal tab
        "LF",   #  0x0a  ^J  '\n' new line
        "VT",   #  0x0b  ^K  '\v' vertical tab
        "FF",   #  0x0c  ^L  '\f' form feed
        "CR",   #  0x0d  ^M  '\r' carriage ret
        "SO",   #  0x0e  ^N  shift out            (LS1)
        "SI",   #  0x0f  ^O  shift in             (LS0)
        "DLE",  #  0x10  ^P  data link escape
        "DC1",  #  0x11  ^Q  device control 1
        "DC2",  #  0x12  ^R  device control 2
        "DC3",  #  0x13  ^S  device control 3
        "DC4",  #  0x14  ^T  device control 4
        "NAK",  #  0x15  ^U  negative ack.
        "SYN",  #  0x16  ^V  synchronous idle
        "ETB",  #  0x17  ^W  end of trans. blk
        "CAN",  #  0x18  ^X  cancel
        "EM",   #  0x19  ^Y  end of medium
        "SUB",  #  0x1a  ^Z  substitute
        "ESC",  #  0x1b  ^[  escape
        "FS",   #  0x1c  ^\  file separator       (IS4)
        "GS",   #  0x1d  ^]  group separator      (IS3)
        "RS",   #  0x1e  ^^  record separator     (IS2)
        "US",   #  0x1f  ^_  unit separator       (IS1)
    ]

    C1 = [
        "reserved",
        "reserved",
        "BPH",
        "NBH",
        "reserved",
        "NEL",
        "SSA",
        "ESA",
        "HTS",
        "HTJ",
        "VTS",
        "PLD",
        "PLU",
        "RI",
        "SS2",
        "SS3",
        "DCS",
        "PU1",
        "PU2",
        "STS",
        "CCH",
        "MW",
        "SPA",
        "EPA",
        "SOS",
        "reserved",
        "SCI",
        "CSI",
        "ST",
        "OSC",
        "PM",
        "APC",
    ]

    icf = [
        "DMI",
        "INT",
        "EMI",
        "RIS",
        "CMD",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "LS2",
        "LS3",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "reserved",
        "LS3R",
        "LS2R",
        "LS1R",
        "reserved",
    ]


    def call(self, name, *args):
        f = getattr(self, name, None)
        if f is not None:
            f(*args)


    def process(self, input):
        input = iter(input)
        for c in input:
            # normal glyph
            if c >= 0x20:
                self.output(c)

            # C0 (except Escape)
            elif c != 0x1b:
                name = self.C0[c]
                self.call(name, (c,), input)

            # Escape
            else:
                n = input.next()
                seq = [c,n]
                intermediate = []

                while n < 0x30:
                    if n < 0x20:
                        self.call("reserved", seq, input)
                    n = input.next()
                    intermediate.append(n)
                seq.extend(intermediate)

                # Control sequence
                if n == 0x5b:
                    # TODO
                    pass

                # Control string
                elif n in self.control_strings:
                    f

                # C1
                else:
                elif 0x40 <= n <= 0x5f:
                    name = self.C1[n-0x40]
                    self.call(name, seq, input)

                # Independent Control Functions
                elif 0x60 <= n <= 0x7f:
                    name = self.icf[n-0x60]
                    self.call(name, seq, input)

                elif d




    def ignore(self, c):
        pass

    def ignore2(self, c):
        c.next()

    def ignore_to_ctrl_g(self, c):
        # Xterm also accepts ESC \, so we do too
        # XXX xterm still interprets other escapes in this ignored message
        x = None
        y = c.next()
        while not (y == '\007' or (x == '\033' and y == '\\')):
            x = y
            y = c.next()

    def ignore_to_esc_backslash(self, c):
        # XXX xterm still interprets other escapes in this ignored message
        x = c.next()
        y = c.next()
        while not (x == '\033' and y == '\\'):
            x = y
            y = c.next()

    def insert(self, c):
        self[self.pos] = ord(c) | self.current_attributes
        self.pos[1] += 1


    def BEL(self,c):
        # todo?
        pass

    def BS(self,c):
        self.move(0, -1)

    def HT(self,c):
        # TODO implement correctly
        self.move(0, 8-(self.pos[1]%8))

    def LF(self,c):
        self.move(1, 0)

    VT = LF
    FF = LF

    def CR(self,c):
        self.move(0, -self.pos[1])

    SI = ignore     # LS0
    SO = ignore     # LS1

    def NEL(self,c):
        self.CR(c)
        self.LF(c)

    # Will probably want to implement the following.
    IND = CR # TODO scrolling?
    HTS = ignore # TODO
    RI = ignore # TODO


    def ESC_EXT(self,c):
        start = ''
        x = c.next()
        a = ''
        if x in '?':
            start = x
            x = c.next()
        while x in '0123456789;':
            a += x
            x = c.next()
        a = a.split(';')
        code = start + x
        try:
            f = ESC_EXT_SEQ[code]
        except KeyError:
            pass
        else:
            f(self, a)


    # List of escape sequences that are ignored and how many characters to
    # ignore.
    ESC_SEQ = {
            '(' : ignore2,  # SCS - Designate G0 font
            ')' : ignore2,  # SCS - Designate G1 font
            '*' : ignore2,  # SCS - Designate G2 font
            '+' : ignore2,  # SCS - Designate G3 font
            ' ' : ignore2,  # S7C1T / C8C1T
            '#' : ignore2,  # DECALN
            'n' : ignore,   # LS2
            'o' : ignore,   # LS3
            'N' : ignore,   # SS2
            'O' : ignore,   # SS3
            '7' : ignore,   # DECSC
            '8' : ignore,   # DECRC
            '=' : ignore,   # DECPAM
            '>' : ignore,   # DECPNM
            'D' : IND,
            'E' : NEL,
            'H' : HTS,
            'M' : RI,
            'P' : ignore_to_esc_backslash,  # DECUDK
            'Z' : ignore,                   # DECID
            'c' : RIS,
            '[' : ESC_EXT,
            ']' : ignore_to_ctrl_g,         # set xterm parameters
            '^' : ignore_to_esc_backslash,  # PM
            # TODO
        }

    def ESC(self, c):
        c = c.next()
        # the following are ignored
        if c[1] in '()*+ #':
            return 3
        if c[1] == 'noNO':
            return 2

        if c[1] == '7':
            # TODO save cursor
            return 2
        if c[1] == '8':
            # TODO restore cursor
            return 2


    interpet = {
            '\000' : ignore     # NUL  '\0'
            '\001' : ignore     # SOH  (start of heading)
            '\002' : ignore     # STX  (start of text)
            '\003' : ignore     # ETX  (end of text)
            '\004' : ignore     # EOT  (end of transmission)
            '\005' : ignore     # ENQ  (enquiry)
            '\006' : ignore     # ACK  (acknowledge)
            '\007' : BEL        # BEL  '\a' (bell)
            '\010' : ignore     # BS   '\b' (backspace)
            '\011' : HT         # HT   '\t' (horizontal tab)
            '\012' : ignore     # LF   '\n' (new line)
            '\013' : VT         # VT   '\v' (vertical tab)
            '\014' : FF         # FF   '\f' (form feed)
            '\015' : CR         # CR   '\r' (carriage ret)
            '\016' : SO         # SO   (shift out)
            '\017' : SI         # SI   (shift in)
            '\020' : ignore     # DLE  (data link escape)
            '\021' : ignore     # DC1  (device control 1)
            '\022' : ignore     # DC2  (device control 2)
            '\023' : ignore     # DC3  (device control 3)
            '\024' : ignore     # DC4  (device control 4)
            '\025' : ignore     # NAK  (negative ack.)
            '\026' : ignore     # SYN  (synchronous idle)
            '\027' : ignore     # ETB  (end of trans. blk)
            '\030' : ignore     # CAN  (cancel)
            '\031' : ignore     # EM   (end of medium)
            '\032' : ignore     # SUB  (substitute)
            '\033' : ESC        # ESC  (escape)
            '\034' : ignore     # FS   (file separator)
            '\035' : ignore     # GS   (group separator)
            '\036' : ignore     # RS   (record separator)
            '\037' : ignore     # US   (unit separator)
            }



    def add_normal(self, c):
        if c == ESC:
            self.add = self.add_escape
        else:

    def add(self, string):
        mode = self.mode
        for c in string:
            if mode == M_NORMAL:
            if mode == '
                if c != ESC:
                    self.append(c)
        self.mode = mode

    def output(self):
        raise NotImplementedError()


def vt100_to_html(s):
    return Screen(s).output()


def process(infilename, outfilename = None):
    if outfilename is None:
        if infilename == '-':
            outfilename = '-'
        else:
            outfilename = infilename + EXT

    # Slurp the input
    if infilename == '-':
        infile = sys.stdin
    else:
        infile = open(infilename, 'rb')
    input = infile.read()
    if infile is not sys.stdin:
        infile.close()

    output = vt100_to_html(input)

    # Write all the output
    if outfilename == '-':
        outfile = sys.stdout
    else:
        outfile = open(outfilename, 'wb')
    outfile.write(output)
    if outfile is not sys.stdout:
        outfile.close()


def main(argv):
    if argv:
        for filename in sys.argv[1:]:
            main(filename)
    else:
        main('-')

if __name__ == "__main__":
    main(sys.argv[1:])
