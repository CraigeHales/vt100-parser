#!/usr/bin/env python

import sys, os

EXT = '.html'


ATTRIBUTES  = 0xffff0000
BOLD        = 0x00010000
UNDERLINE   = 0x00020000
BLINK       = 0x00040000
INVERSE     = 0x00080000
FG_POS      = 20
FG_POS      = 24
FG          = 0xf << FG_POS
BG          = 0xf << BG_POS
BLACK       = 0
RED         = 1
GREEN       = 2
YELLOW      = 3
BLUE        = 4
MAGENTA     = 5
CYAN        = 6
WHITE       = 7
COLOR_SET   = 8
FG_BLACK    = (BLACK   | COLOR_SET) << FG_POS
FG_RED      = (RED     | COLOR_SET) << FG_POS
FG_GREEN    = (GREEN   | COLOR_SET) << FG_POS
FG_YELLOW   = (YELLOW  | COLOR_SET) << FG_POS
FG_BLUE     = (BLUE    | COLOR_SET) << FG_POS
FG_MAGENTA  = (MAGENTA | COLOR_SET) << FG_POS
FG_CYAN     = (CYAN    | COLOR_SET) << FG_POS
FG_WHITE    = (WHITE   | COLOR_SET) << FG_POS
BG_BLACK    = (BLACK   | COLOR_SET) << BG_POS
BG_RED      = (RED     | COLOR_SET) << BG_POS
BG_GREEN    = (GREEN   | COLOR_SET) << BG_POS
BG_YELLOW   = (YELLOW  | COLOR_SET) << BG_POS
BG_BLUE     = (BLUE    | COLOR_SET) << BG_POS
BG_MAGENTA  = (MAGENTA | COLOR_SET) << BG_POS
BG_CYAN     = (CYAN    | COLOR_SET) << BG_POS
BG_WHITE    = (WHITE   | COLOR_SET) << BG_POS




class Terminal (object):
    def __init__(self):
        self.width = 80
        self.height = 24
        self.pos = [0,0]
        self.current_attributes = 0
        self.history = []
        self.screen = [[]]
        self.add = self.add_normal

    def move(self, down, right):
        self.pos[0] += max(-self.pos[0], down)
        self.pos[1] += max(-self.pos[1], right)
        if self.pos[0] > self.height:
            extra = self.pos[0] - self.height
            self.history.extend( self.screen[:extra] )
            del self.screen[:extra]

    def __setattr__(self, pos, value):
        r,c = pos
        if r >= len(self.screen):
            if r > self.height:
                self.history.extend( self.screen[]) # TODO



    C0 = [
        "NUL",  #  0x00  ^@  '\0'
        "SOH",  #  0x01  ^A  start of heading
        "STX",  #  0x02  ^B  start of text
        "ETX",  #  0x03  ^C  end of text
        "EOT",  #  0x04  ^D  end of transmission
        "ENQ",  #  0x05  ^E  enquiry
        "ACK",  #  0x06  ^F  acknowledge
        "BEL",  #  0x07  ^G  '\a' bell
        "BS",   #  0x08  ^H  '\b' backspace
        "HT",   #  0x09  ^I  '\t' horizontal tab
        "LF",   #  0x0a  ^J  '\n' new line
        "VT",   #  0x0b  ^K  '\v' vertical tab
        "FF",   #  0x0c  ^L  '\f' form feed
        "CR",   #  0x0d  ^M  '\r' carriage ret
        "SO",   #  0x0e  ^N  shift out            (LS1)
        "SI",   #  0x0f  ^O  shift in             (LS0)
        "DLE",  #  0x10  ^P  data link escape
        "DC1",  #  0x11  ^Q  device control 1
        "DC2",  #  0x12  ^R  device control 2
        "DC3",  #  0x13  ^S  device control 3
        "DC4",  #  0x14  ^T  device control 4
        "NAK",  #  0x15  ^U  negative ack.
        "SYN",  #  0x16  ^V  synchronous idle
        "ETB",  #  0x17  ^W  end of trans. blk
        "CAN",  #  0x18  ^X  cancel
        "EM",   #  0x19  ^Y  end of medium
        "SUB",  #  0x1a  ^Z  substitute
        "ESC",  #  0x1b  ^[  escape
        "FS",   #  0x1c  ^\  file separator       (IS4)
        "GS",   #  0x1d  ^]  group separator      (IS3)
        "RS",   #  0x1e  ^^  record separator     (IS2)
        "US",   #  0x1f  ^_  unit separator       (IS1)
    ]

    escapes = {
        # (0x40,)
        # (0x41,)
        (0x42,) : "BPH",
        (0x43,) : "NBH",
        # (0x44,)
        (0x45,) : "NEL",
        (0x46,) : "SSA",
        (0x47,) : "ESA",
        (0x48,) : "HTS",
        (0x49,) : "HTJ",
        (0x4a,) : "VTS",
        (0x4b,) : "PLD",
        (0x4c,) : "PLU",
        (0x4d,) : "RI",
        (0x4e,) : "SS2",
        (0x4f,) : "SS3",
        (0x50,) : "DCS",
        (0x51,) : "PU1",
        (0x52,) : "PU2",
        (0x53,) : "STS",
        (0x54,) : "CCH",
        (0x55,) : "MW",
        (0x56,) : "SPA",
        (0x57,) : "EPA",
        (0x58,) : "SOS",
        # (0x59,)
        (0x5a,) : "SCI",
        (0x5b,) : "CSI",
        (0x5c,) : "ST",
        (0x5d,) : "OSC",
        (0x5e,) : "PM",
        (0x5f,) : "APC",
        (0x60,) : "DMI",
        (0x61,) : "INT",
        (0x62,) : "EMI",
        (0x63,) : "RIS",
        (0x64,) : "CMD",
        # (0x65,)
        # (0x66,)
        # (0x67,)
        # (0x68,)
        # (0x69,)
        # (0x6a,)
        # (0x6b,)
        # (0x6c,)
        # (0x6d,)
        (0x6e,) : "LS2",
        (0x6f,) : "LS3",
        # (0x70,)
        # (0x71,)
        # (0x72,)
        # (0x73,)
        # (0x74,)
        # (0x75,)
        # (0x76,)
        # (0x77,)
        # (0x78,)
        # (0x79,)
        # (0x7a,)
        # (0x7b,)
        (0x7c,) : "LS3R",
        (0x7d,) : "LS2R",
        (0x7e,) : "LS1R",
        # (0x7f,)
    }



    def call(self, name, *args):
        f = getattr(self, name, None)
        if f is not None:
            f(*args)


    def process(self, input):
        input = iter(input)
        for c in input:
            if c >= 0x20:
                self.output(c)
            else:
                name = self.C0[c]
                self.call(name, (c,), input)


    def ESC(self, seq_in, input):
        seq = list(seq_in)
        if len(seq) == 1:
            n = input.next()
        else:
            n = seq[-1]
        seq.append(n)
        intermediate = []

        # Interpret the intermediate characters.
        while n < 0x30:
            if n < 0x20:
                # Embedded escape sequence; ESC, CAN, SUB end the current one.
                name = self.C0.get(n)
                if name == "ESC":
                    return self.call(name, (n,), input)
                if name in ("CAN", "SUB"):
                    return self.call(name, seq, input)
                else:
                    # The standards do not define what to do if any other
                    # control character is within the escape sequence.  Xterm
                    # just processes the escape recursively, so that's what we
                    # do here.
                    self.call(name, (n,), input)
            intermediate.append(n)
            n = input.next()
            seq.append(n)

        code = tuple([n] + intermediate)
        name = self.escapes.get(code)
        self.call(name, seq, input)


    # -------------------- Control String Functions --------------------

    def read_control_string(self, input, allow_BEL = False):
        """Read the control string and return the result as a list.  If the
        control string was cancelled with SUB, return None."""
        self.finished_reading_control_string = False
        out = []
        while True:
            n = input.next()
            if n < 0x20:
                name = self.C0[n]
                seq = [n]
                if name == "SUB":
                    # cancel
                    self.call(name, seq, input)
                    return None
                elif allow_BEL and name == "BEL":
                    # finish
                    break
                elif name == "ESC":
                    p = input.next()
                    if p == 0x5c:   # ST - string terminator
                        # finish
                        break
                    else:
                        # call the embedded escape sequence
                        seq.append(p)
                        self.call(name, seq, input)
                        # Cancel if we read another control string
                        if self.finished_reading_control_string:
                            return None
                else:
                    # call the embedded control
                    self.call(name, seq, input)
            else:
                out.append(n)
        self.finished_reading_control_string = True
        return out

    
    def APC(self, seq_in, input):
        self.read_control_string(input)

    def DCS(self, seq_in, input):
        self.read_control_string(input)

    def OSC(self, seq_in, input):
        self.read_control_string(input, True)

    def SOS(self, seq_in, input):
        self.read_control_string(input)

    def PM(self, seq_in, input):
        self.read_control_string(input)




    def BS(self,c):
        self.move(0, -1)

    def HT(self,c):
        # TODO implement correctly
        self.move(0, 8-(self.pos[1]%8))

    def LF(self,c):
        self.move(1, 0)

    VT = LF
    FF = LF

    def CR(self,c):
        self.move(0, -self.pos[1])

    SI = ignore     # LS0
    SO = ignore     # LS1

    def NEL(self,c):
        self.CR(c)
        self.LF(c)

    # Will probably want to implement the following.
    IND = CR # TODO scrolling?
    HTS = ignore # TODO
    RI = ignore # TODO




def vt100_to_html(s):
    return Screen(s).output()


def process(infilename, outfilename = None):
    if outfilename is None:
        if infilename == '-':
            outfilename = '-'
        else:
            outfilename = infilename + EXT

    # Slurp the input
    if infilename == '-':
        infile = sys.stdin
    else:
        infile = open(infilename, 'rb')
    input = infile.read()
    if infile is not sys.stdin:
        infile.close()

    output = vt100_to_html(input)

    # Write all the output
    if outfilename == '-':
        outfile = sys.stdout
    else:
        outfile = open(outfilename, 'wb')
    outfile.write(output)
    if outfile is not sys.stdout:
        outfile.close()


def main(argv):
    if argv:
        for filename in sys.argv[1:]:
            main(filename)
    else:
        main('-')

if __name__ == "__main__":
    main(sys.argv[1:])
