#!/usr/bin/env python

import sys, os
import array

EXT = '.html'


ATTRIBUTES  = 0xffff0000
BOLD        = 0x00010000
UNDERLINE   = 0x00020000
BLINK       = 0x00040000
INVERSE     = 0x00080000
FG_POS      = 20
FG_POS      = 24
FG          = 0xf << FG_POS
BG          = 0xf << BG_POS
BLACK       = 0
RED         = 1
GREEN       = 2
YELLOW      = 3
BLUE        = 4
MAGENTA     = 5
CYAN        = 6
WHITE       = 7
COLOR_SET   = 8
FG_BLACK    = (BLACK   | COLOR_SET) << FG_POS
FG_RED      = (RED     | COLOR_SET) << FG_POS
FG_GREEN    = (GREEN   | COLOR_SET) << FG_POS
FG_YELLOW   = (YELLOW  | COLOR_SET) << FG_POS
FG_BLUE     = (BLUE    | COLOR_SET) << FG_POS
FG_MAGENTA  = (MAGENTA | COLOR_SET) << FG_POS
FG_CYAN     = (CYAN    | COLOR_SET) << FG_POS
FG_WHITE    = (WHITE   | COLOR_SET) << FG_POS
BG_BLACK    = (BLACK   | COLOR_SET) << BG_POS
BG_RED      = (RED     | COLOR_SET) << BG_POS
BG_GREEN    = (GREEN   | COLOR_SET) << BG_POS
BG_YELLOW   = (YELLOW  | COLOR_SET) << BG_POS
BG_BLUE     = (BLUE    | COLOR_SET) << BG_POS
BG_MAGENTA  = (MAGENTA | COLOR_SET) << BG_POS
BG_CYAN     = (CYAN    | COLOR_SET) << BG_POS
BG_WHITE    = (WHITE   | COLOR_SET) << BG_POS



def _to_code(s):
    return tuple(ord(c) for c in s)


class Terminal (object):
    def __init__(self):
        self.width = 80
        self.height = 24
        self.pos = [0,0]
        self.current_attributes = 0
        self.history = []
        self.screen = [[]]
        self.add = self.add_normal

    def move(self, down, right):
        self.pos[0] += max(-self.pos[0], down)
        self.pos[1] += max(-self.pos[1], right)
        if self.pos[0] > self.height:
            extra = self.pos[0] - self.height
            self.history.extend( self.screen[:extra] )
            del self.screen[:extra]

    def __setattr__(self, pos, value):
        r,c = pos
        if r >= len(self.screen):
            if r > self.height:
                self.history.extend( self.screen[]) # TODO



    C0 = [
        "NUL",  #  0x00  ^@  '\0'
        "SOH",  #  0x01  ^A  start of heading
        "STX",  #  0x02  ^B  start of text
        "ETX",  #  0x03  ^C  end of text
        "EOT",  #  0x04  ^D  end of transmission
        "ENQ",  #  0x05  ^E  enquiry
        "ACK",  #  0x06  ^F  acknowledge
        "BEL",  #  0x07  ^G  '\a' bell
        "BS",   #  0x08  ^H  '\b' backspace
        "HT",   #  0x09  ^I  '\t' horizontal tab
        "LF",   #  0x0a  ^J  '\n' new line
        "VT",   #  0x0b  ^K  '\v' vertical tab
        "FF",   #  0x0c  ^L  '\f' form feed
        "CR",   #  0x0d  ^M  '\r' carriage ret
        "SO",   #  0x0e  ^N  shift out            (LS1)
        "SI",   #  0x0f  ^O  shift in             (LS0)
        "DLE",  #  0x10  ^P  data link escape
        "DC1",  #  0x11  ^Q  device control 1
        "DC2",  #  0x12  ^R  device control 2
        "DC3",  #  0x13  ^S  device control 3
        "DC4",  #  0x14  ^T  device control 4
        "NAK",  #  0x15  ^U  negative ack.
        "SYN",  #  0x16  ^V  synchronous idle
        "ETB",  #  0x17  ^W  end of trans. blk
        "CAN",  #  0x18  ^X  cancel
        "EM",   #  0x19  ^Y  end of medium
        "SUB",  #  0x1a  ^Z  substitute
        "ESC",  #  0x1b  ^[  escape
        "FS",   #  0x1c  ^\  file separator       (IS4)
        "GS",   #  0x1d  ^]  group separator      (IS3)
        "RS",   #  0x1e  ^^  record separator     (IS2)
        "US",   #  0x1f  ^_  unit separator       (IS1)
    ]

    escapes = {
        # '@'
        # 'A'
        'B' : "BPH",
        'C' : "NBH",
        # 'D'
        'E' : "NEL",
        'F' : "SSA",
        'G' : "ESA",
        'H' : "HTS",
        'I' : "HTJ",
        'J' : "VTS",
        'K' : "PLD",
        'L' : "PLU",
        'M' : "RI",
        'N' : "SS2",
        'O' : "SS3",
        'P' : "DCS",
        'Q' : "PU1",
        'R' : "PU2",
        'S' : "STS",
        'T' : "CCH",
        'U' : "MW",
        'V' : "SPA",
        'W' : "EPA",
        'X' : "SOS",
        # 'Y'
        'Z' : "SCI",
        '[' : "CSI",
        '\\' : "ST",
        ']' : "OSC",
        '^' : "PM",
        '_' : "APC",
        '`' : "DMI",
        'a' : "INT",
        'b' : "EMI",
        'c' : "RIS",
        'd' : "CMD",
        # 'e'
        # 'f'
        # 'g'
        # 'h'
        # 'i'
        # 'j'
        # 'k'
        # 'l'
        # 'm'
        'n' : "LS2",
        'o' : "LS3",
        # 'p'
        # 'q'
        # 'r'
        # 's'
        # 't'
        # 'u'
        # 'v'
        # 'w'
        # 'x'
        # 'y'
        # 'z'
        # '{'
        '|' : "LS3R",
        '}' : "LS2R",
        '~' : "LS1R",
        # '\x7f'
    }



    def call(self, name, *args):
        f = getattr(self, name, None)
        if f is not None:
            f(*args)


    def process(self, input):
        input = iter(input)
        for c in input:
            if c >= 0x20:
                self.output(c)
            else:
                name = self.C0[c]
                self.call(name, (c,), input)


    def ESC(self, seq_in, input):
        seq = list(seq_in)
        if len(seq) == 1:
            n = input.next()
        else:
            n = seq[-1]
        code = array('B'))

        # Interpret the intermediate characters.
        while n < 0x30:
            if n < 0x20:
                # Embedded escape sequence; ESC, CAN, SUB end the current one.
                name = self.C0.get(n)
                if name == "ESC":
                    return self.call(name, (n,), input)
                if name in ("CAN", "SUB"):
                    return self.call(name, seq, input)
                else:
                    # The standards do not define what to do if any other
                    # control character is within the escape sequence.  Xterm
                    # just processes the escape recursively, so that's what we
                    # do here.
                    self.call(name, (n,), input)
            else:
                code.append(n)
            n = input.next()
        code.append(n)
        seq.extend(code)

        name = self.escapes.get(code.tostring())
        self.call(name, seq, input)


    # -------------------- Control String Functions --------------------

    def read_control_string(self, input, allow_BEL = False):
        """Read the control string and return the result as a list.  If the
        control string was cancelled with SUB, return None."""
        self.finished_reading_control_string = False
        out = []
        while True:
            n = input.next()
            if n < 0x20:
                name = self.C0[n]
                seq = [n]
                if name == "SUB":
                    # cancel
                    self.call(name, seq, input)
                    return None
                elif allow_BEL and name == "BEL":
                    # finish
                    break
                elif name == "ESC":
                    p = input.next()
                    if p == ord('\\'):  # ST - string terminator
                        # finish
                        break
                    else:
                        # call the embedded escape sequence
                        seq.append(p)
                        self.call(name, seq, input)
                        # Cancel if we read another control string
                        if self.finished_reading_control_string:
                            return None
                else:
                    # call the embedded control
                    self.call(name, seq, input)
            else:
                out.append(n)
        self.finished_reading_control_string = True
        return out

    
    def APC(self, seq_in, input):
        self.read_control_string(input)

    def DCS(self, seq_in, input):
        self.read_control_string(input)

    def OSC(self, seq_in, input):
        self.read_control_string(input, True)

    def SOS(self, seq_in, input):
        self.read_control_string(input)

    def PM(self, seq_in, input):
        self.read_control_string(input)


    # --------------------                          --------------------


    def BS(self,c):
        self.move(0, -1)

    def HT(self,c):
        # TODO implement correctly
        self.move(0, 8-(self.pos[1]%8))

    def LF(self,c):
        self.move(1, 0)

    VT = LF
    FF = LF

    def CR(self,c):
        self.move(0, -self.pos[1])

    SI = ignore     # LS0
    SO = ignore     # LS1

    def NEL(self,c):
        self.CR(c)
        self.LF(c)

    # Will probably want to implement the following.
    IND = CR # TODO scrolling?
    HTS = ignore # TODO
    RI = ignore # TODO




def vt100_to_html(s):
    return Screen(s).output()


def process(infilename, outfilename = None):
    if outfilename is None:
        if infilename == '-':
            outfilename = '-'
        else:
            outfilename = infilename + EXT

    # Slurp the input
    if infilename == '-':
        infile = sys.stdin
    else:
        infile = open(infilename, 'rb')
    input = infile.read()
    if infile is not sys.stdin:
        infile.close()

    output = vt100_to_html(input)

    # Write all the output
    if outfilename == '-':
        outfile = sys.stdout
    else:
        outfile = open(outfilename, 'wb')
    outfile.write(output)
    if outfile is not sys.stdout:
        outfile.close()


def main(argv):
    if argv:
        for filename in sys.argv[1:]:
            main(filename)
    else:
        main('-')

if __name__ == "__main__":
    main(sys.argv[1:])
