#!/usr/bin/env python

import sys, os
import array


def decorator_setter(deco):
    name = deco.func_name
    def decorator_with_arg(arg):
        def decorator(f):
            setattr(f, name, arg)
        return decorator
    return decorator_with_arg


def control_code(code):
    def deco(f):
        f.control_code = code
    return deco

def esc_seq(seq):
    def deco(f):
        f.esc_seq = seq
    return deco

def csi_seq(seq):
    def deco(f):
        f.csi_seq = seq
    return deco

def apc_seq(seq):
    def deco(f):
        f.apc_seq = seq
    return deco

def osc_seq(seq):
    def deco(f):
        f.osc_seq = seq
    return deco

def dsc_seq(seq):
    def deco(f):
        f.dsc_seq = seq
    return deco

def pm_seq(seq):
    def deco(f):
        f.pm_seq = seq
    return deco




ATTRIBUTES  = 0xffff0000
BOLD        = 0x00010000
UNDERLINE   = 0x00020000
BLINK       = 0x00040000
INVERSE     = 0x00080000
FG_POS      = 20
FG_POS      = 24
FG          = 0xf << FG_POS
BG          = 0xf << BG_POS
BLACK       = 0
RED         = 1
GREEN       = 2
YELLOW      = 3
BLUE        = 4
MAGENTA     = 5
CYAN        = 6
WHITE       = 7
COLOR_SET   = 8
FG_BLACK    = (BLACK   | COLOR_SET) << FG_POS
FG_RED      = (RED     | COLOR_SET) << FG_POS
FG_GREEN    = (GREEN   | COLOR_SET) << FG_POS
FG_YELLOW   = (YELLOW  | COLOR_SET) << FG_POS
FG_BLUE     = (BLUE    | COLOR_SET) << FG_POS
FG_MAGENTA  = (MAGENTA | COLOR_SET) << FG_POS
FG_CYAN     = (CYAN    | COLOR_SET) << FG_POS
FG_WHITE    = (WHITE   | COLOR_SET) << FG_POS
BG_BLACK    = (BLACK   | COLOR_SET) << BG_POS
BG_RED      = (RED     | COLOR_SET) << BG_POS
BG_GREEN    = (GREEN   | COLOR_SET) << BG_POS
BG_YELLOW   = (YELLOW  | COLOR_SET) << BG_POS
BG_BLUE     = (BLUE    | COLOR_SET) << BG_POS
BG_MAGENTA  = (MAGENTA | COLOR_SET) << BG_POS
BG_CYAN     = (CYAN    | COLOR_SET) << BG_POS
BG_WHITE    = (WHITE   | COLOR_SET) << BG_POS



def _to_code(s):
    return tuple(ord(c) for c in s)


class Terminal (object):
    def __init__(self):
        self.width = 80
        self.height = 24
        self.pos = [0,0]
        self.current_attributes = 0
        self.history = []
        self.screen = [[]]
        self.add = self.add_normal

    def move(self, down, right):
        self.pos[0] += max(-self.pos[0], down)
        self.pos[1] += max(-self.pos[1], right)
        if self.pos[0] > self.height:
            extra = self.pos[0] - self.height
            self.history.extend( self.screen[:extra] )
            del self.screen[:extra]

    def __setattr__(self, pos, value):
        r,c = pos
        if r >= len(self.screen):
            if r > self.height:
                self.history.extend( self.screen[]) # TODO



    C0 = [
        "NUL",  #  0x00  ^@  '\0'
        "SOH",  #  0x01  ^A  start of heading
        "STX",  #  0x02  ^B  start of text
        "ETX",  #  0x03  ^C  end of text
        "EOT",  #  0x04  ^D  end of transmission
        "ENQ",  #  0x05  ^E  enquiry
        "ACK",  #  0x06  ^F  acknowledge
        "BEL",  #  0x07  ^G  '\a' bell
        "BS",   #  0x08  ^H  '\b' backspace
        "HT",   #  0x09  ^I  '\t' horizontal tab
        "LF",   #  0x0a  ^J  '\n' new line
        "VT",   #  0x0b  ^K  '\v' vertical tab
        "FF",   #  0x0c  ^L  '\f' form feed
        "CR",   #  0x0d  ^M  '\r' carriage ret
        "SO",   #  0x0e  ^N  shift out            (LS1)
        "SI",   #  0x0f  ^O  shift in             (LS0)
        "DLE",  #  0x10  ^P  data link escape
        "DC1",  #  0x11  ^Q  device control 1
        "DC2",  #  0x12  ^R  device control 2
        "DC3",  #  0x13  ^S  device control 3
        "DC4",  #  0x14  ^T  device control 4
        "NAK",  #  0x15  ^U  negative ack.
        "SYN",  #  0x16  ^V  synchronous idle
        "ETB",  #  0x17  ^W  end of trans. blk
        "CAN",  #  0x18  ^X  cancel
        "EM",   #  0x19  ^Y  end of medium
        "SUB",  #  0x1a  ^Z  substitute
        "ESC",  #  0x1b  ^[  escape
        "FS",   #  0x1c  ^\  file separator       (IS4)
        "GS",   #  0x1d  ^]  group separator      (IS3)
        "RS",   #  0x1e  ^^  record separator     (IS2)
        "US",   #  0x1f  ^_  unit separator       (IS1)
    ]

    escapes = {
      # '0'
      # '1'
      # '2'
      # '3'
      # '4'
      # '5'
      # '6'
        '7' : "DECSC",      # Save Cursor
        '8' : "DECRC",      # Restore Cursor
      # '9'
      # ':'
      # ';'
      # '<'
        '=' : "DECPAM",
        '>' : "DECPNM",
      # '?'
      # '@'
      # 'A'
        'B' : "BPH",
        'C' : "NBH",
        'D' : "IND",
        'E' : "NEL",
        'F' : "SSA",        # also hpLowerleftBugCompat in xterm
        'G' : "ESA",
        'H' : "HTS",
        'I' : "HTJ",
        'J' : "VTS",
        'K' : "PLD",
        'L' : "PLU",
        'M' : "RI",
        'N' : "SS2",
        'O' : "SS3",
        'P' : "DCS",
        'Q' : "PU1",
        'R' : "PU2",
        'S' : "STS",
        'T' : "CCH",
        'U' : "MW",
        'V' : "SPA",
        'W' : "EPA",
        'X' : "SOS",
      # 'Y'
        'Z' : "SCI",
        '[' : "CSI",
        '\\' : "ST",
        ']' : "OSC",
        '^' : "PM",
        '_' : "APC",
        '`' : "DMI",
        'a' : "INT",
        'b' : "EMI",
        'c' : "RIS",
        'd' : "CMD",
      # 'e'
      # 'f'
      # 'g'
      # 'h'
      # 'i'
      # 'j'
      # 'k'
        'l' : "memory_lock",    # Memory Lock (per HP terminals)
        'm' : "memory_reset",   # Memory Unlock (per HP terminals)
        'n' : "LS2",
        'o' : "LS3",
      # 'p'
      # 'q'
      # 'r'
      # 's'
      # 't'
      # 'u'
      # 'v'
      # 'w'
      # 'x'
      # 'y'
      # 'z'
      # '{'
        '|' : "LS3R",
        '}' : "LS2R",
        '~' : "LS1R",
      # '\x7f'

        ' F' : "S7C1T",     # 7-bit controls
        ' G' : "S8C1T",     # 8-bit controls
        ' L' : "ansi_conformance_1",
        ' M' : "ansi_conformance_2",
        ' N' : "ansi_conformance_3",
        '#3' : "DECDHL",    #  DEC double-height line, top half
        '#4' : "DECDHL",    #  DEC double-height line, bottom half
        '#5' : "DECSWL",    #  DEC single-width line
        '#6' : "DECDWL",    #  DEC double-width line
        '#8' : "DECALN",    #  DEC Screen Alignment Test
        '%@' : "select_default_charset",
        '%G' : "select_utf8_charset",
      # '(C'     Designate G0 Character Set (ISO 2022) ; C = character
      # ')C'     Designate G1 Character Set (ISO 2022) ; C = character
      # '*C'     Designate G2 Character Set (ISO 2022) ; C = character
      # '+C'     Designate G3 Character Set (ISO 2022) ; C = character
    }

    control_sequences = {
        '@' : "ICH",
        'A' : "CUU",
        'B' : "CUD",
        'C' : "CUF",
        'D' : "CUB",
        'E' : "CNL",
        'F' : "CPL",
        'G' : "CHA",
        'H' : "CUP",
        'I' : "CHT",
        'J' : "ED",
        'K' : "EL",
        'L' : "IL",
        'M' : "DL",
        'N' : "EF",
        'O' : "EA",
        'P' : "DCH",
        'Q' : "SSE",
        'R' : "CPR",
        'S' : "SU",
        'T' : "SD",
        'U' : "NP",
        'V' : "PP",
        'W' : "CTC",
        'X' : "ECH",
        'Y' : "CVT",
        'Z' : "CBT",
        '[' : "SRS",
        '\\' : "PTX",
        ']' : "SDS",
        '^' : "SIMD",
      # '_'
        '`' : "HPA",
        'a' : "HPR",
        'b' : "REP",
        'c' : "DA",
        'd' : "VPA",
        'e' : "VPR",
        'f' : "HVP",
        'g' : "TBC",
        'h' : "SM",
        'i' : "MC",
        'j' : "HPB",
        'k' : "VPB",
        'l' : "RM",
        'm' : "SGR",
        'n' : "DSR",
        'o' : "DAQ",

        'p' : "DECSSL",         # Select Set-Up Language
        'q' : "DECLL",          # Load LEDs
        'r' : "DECSTBM",        # Set Top and Bottom Margins
        's' : "DECSLRM",        # Set Left and Right Margins
        't' : "DECSLPP",        # Set Lines per Physical Page
        'u' : "DECSHTS",        # Set Horizontal Tabulation Stops
        'v' : "DECSVTS",        # Set Vertical Tabulation Stops
        'w' : "DECSHORP",       # Set Horizontal Pitch
        'x' : "DECREQTPARM",    # Request Terminal Parameters
        'y' : "DECTST",         # Invoke Confidence Test
        'z' : "DECVERP",        # Set Vertical Pitch
      # '{'
        '|' : "DECTTC",         # Select Transmit Termination Character
        '}' : "DECPRO",         # Set Protected Field Attributes
        '~' : "DECFNK",         # Function Key

        ' @' : "SL",
        ' A' : "SR",
        ' B' : "GSM",
        ' C' : "GSS",
        ' D' : "FNT",
        ' E' : "TSS",
        ' F' : "JFY",
        ' G' : "SPI",
        ' H' : "QUAD",
        ' I' : "SSU",
        ' J' : "PFS",
        ' K' : "SHS",
        ' L' : "SVS",
        ' M' : "IGS",
      # ' N'
        ' O' : "IDCS",
        ' P' : "PPA",
        ' Q' : "PPR",
        ' R' : "PPB",
        ' S' : "SPD",
        ' T' : "DTA",
        ' U' : "SHL",
        ' V' : "SLL",
        ' W' : "FNK",
        ' X' : "SPQR",
        ' Y' : "SEF",
        ' Z' : "PEC",
        ' [' : "SSW",
        ' \\' : "SACS",
        ' ]' : "SAPV",
        ' ^' : "STAB",
        ' _' : "GCC",
        ' `' : "TATE",
        ' a' : "TALE",
        ' b' : "TAC",
        ' c' : "TCC",
        ' d' : "TSR",
        ' e' : "SCO",
        ' f' : "SRCS",
        ' g' : "SCS",
        ' h' : "SLS",
      # ' i'
      # ' j'
        ' k' : "SCP",
      # ' l'
      # ' m'
      # ' n'
      # ' o'

        ' p' : "DECSSCLS",      # Set Scroll Speed
        ' q' : "DECSCUSR",      # Set Cursor Style
        ' r' : "DECSKCV",       # Set Keyclick Volume
        ' s' : "DECNS",         # New Sheet
        ' t' : "DECSWBV",       # Set Warning Bell Volume
        ' u' : "DECSMBV",       # Set Margin Bell Volume
        ' v' : "DECSLCK",       # Set Lock Key Style
        ' w' : "DECSITF",       # Select Input Tray Failover
        ' x' : "DECSDPM",       # Set Duplex Print Mode
      # ' y'
        ' z' : "DECVPFS",       # Variable Page Format Select
        ' {' : "DECSSS",        # Set Sheet Size
        ' |' : "DECRVEC",       # Draw Relative Vector
        ' }' : "DECKBD",        # Keyboard Language Selection
        ' ~' : "DECTME",        # Terminal Mode Emulation

        '!p' : "DECSTR",        # Soft Terminal Reset
      # '!q'
      # '!r'
        '!s' : "DECFIL",        # Right Justification
      # '!t'
      # '!u'
        '!v' : "DECASFC",       # Automatic Sheet Feeder Control
        '!w' : "DECUND",        # Programmable Underline Character
        '!x' : "DECPTS",        # Printwheel Table Select
        '!y' : "DECSS",         # Set Space Size
      # '!z'
      # '!{'
        '!|' : "DECVEC",        # Draw Vector
        '!}' : "DECFIN",        # Document Finishing
      # '!~'

        '"p' : "DECSCL",        # Set Conformance Level
        '"q' : "DECSCA",        # Select Character Attributes
      # '"r'
        '"s' : "DECPWA",        # Page Width Alignment
        '"t' : "DECSRFR",       # Select Refresh Rate
        '"u' : "DECSTRL",       # Set Transmit Rate Limit
        '"v' : "DECRQDE",       # Request Device Extent
        '"w' : "DECRPDE",       # Report Device Extent
        '"x' : "DECFCR",        # Font Configuration Request
      # '"y'
        '"z' : "DECDEN",        # Select Density
        '"{' : "DECRFS",        # Request Font Status
      # '"|'
      # '"}'
      # '"~'

        '$p' : "DECRQM",        # Request Mode Settings
        '$q' : "DECSDDT",       # Select Disconnect Delay Time
        '$r' : "DECCARA",       # Change Attributes in Rectangular Area
        '$s' : "DECSPRTT",      # Select Printer Type
        '$t' : "DECRARA",       # Reverse Attributes in Rectangular Area
        '$u' : "DECRQTSR",      # Request Terminal State Report
        '$v' : "DECCRA",        # Copy Rectangular Area
        '$w' : "DECRQPSR",      # Request Presentation State Report
        '$x' : "DECFRA",        # Fill Rectangular Area
        '$y' : "DECRPM",        # Report Mode Settings
        '$z' : "DECERA",        # Erase Rectangular Area
        '${' : "DECSERA",       # Selective Erase Rectangular Area
        '$|' : "DECSCPP",       # Set Columns Per Page
        '$}' : "DECSASD",       # Select Active Status Display
        '$~' : "DECSSDT",       # Select Status Display Type

      # '&p'
        '&q' : "DECSNC",        # Set Number of Copies
      # '&r'
      # '&s'
      # '&t'
        '&u' : "DECRQUPSS",     # Request User-Preferred Supplemental Set
      # '&v'
        '&w' : "DECLRP",        # Locator Report
        '&x' : "DECES",         # Enable Session
      # '&y'
      # '&z'
      # '&{'
      # '&|'
      # '&}'
      # '&~'

      # "'p"
        "'q" : "DECSBCA",       # Select Bar Code Attributes
      # "'r"
        "'s" : "DECTLTC",       # Transmit Line Termination Characters
      # "'t"
      # "'u"
      # "'v"
        "'w" : "DECEFR",        # Enable Filter Rectangle
      # "'x"
      # "'y"
        "'z" : "DECELR",        # Enable Locator Reports
        "'{" : "DECSLE",        # Select Locator Events
        "'|" : "DECRQLP",       # Request Locator Position
        "'}" : "DECIC",         # Insert Column
        "'~" : "DECDC",         # Delete Column

        ')p' : "DECSDPT",       # Select Digital Printed Data Type
      # ')q'
      # ')r'
      # ')s'
      # ')t'
      # ')u'
      # ')v'
      # ')w'
      # ')x'
      # ')y'
      # ')z'
      # '){'
      # ')|'
        ')}' : "DECSTGLT",      # Select Text/Graphics Look-Up Table

        '*p' : "DECSPPCS",      # Select ProPrinter Character Set
        '*q' : "DECSRC",        # Secure Reset Confirmation
        '*r' : "DECSCS",        # Select Communication Speed
        '*s' : "DECSFC",        # Select Flow Control
      # '*t'
        '*u' : "DECSCP",        # Select Communication Port
      # '*v'
      # '*w'
        '*x' : "DECSACE",       # Select Attribute Change Extent
        '*y' : "DECRQCRA",      # Request Checksum of Rectangular Area
        '*z' : "DECINVM",       # Invoke Macro
        '*{' : "DECMSR",        # Macro Space Report
        '*|' : "DECSNLS",       # Select Number of Lines per Screen
        '*}' : "DECLFKC",       # Local Function Key Control
      # '*~'

        '+p' : "DECSR",         # Secure Reset
        '+q' : "DECELF",        # Enable Local Functions
        '+r' : "DECSMKR",       # Select Modifier Key Reporting
      # '+s'
      # '+t'
      # '+u'
        '+v' : "DECMM",         # Memory Management
        '+w' : "DECSPP",        # Set Port Parameter
        '+x' : "DECRQPKFM",     # Program Key Free Memory Inquiry
        '+y' : "DECPKFMR",      # Program Key Free Memory Report
        '+z' : "DECPKA",        # Program Key Action
      # '+{'
      # '+|'
      # '+}'
      # '+~'

        ',p' : "DECLTOD",       # Load Time of Day
        ',q' : "DECTID",        # Select Terminal ID
      # ',r'
      # ',s'
      # ',t'
        ',u' : "DECRQKT",       # Key Type Inquiry
        ',v' : "DECRPKT",       # Report Key Type
        ',w' : "DECRQKD",       # Request Key Definition
        ',x' : "DECSPMA",       # Session Page Memory Allocation
        ',y' : "DECUS",         # Update Session
        ',z' : "DECDLDA",       # Down Line Load Allocation
        ',{' : "DECSZS",        # Select Zero Symbol
        ',|' : "DECAC",         # Assign Color
        ',}' : "DECATC",        # Alternate Text Color
        ',~' : "DECPS",         # Play Sound

        '-p' : "DECARR",        # Select Auto Repeat Rate
        '-q' : "DECCRTST",      # CRT Saver Timing
        '-r' : "DECSEST",       # Energy Saver Timing
      # '-s'
      # '-t'
      # '-u'
      # '-v'
      # '-w'
      # '-x'
      # '-y'
      # '-z'
      # '-{'
      # '-|'
      # '-}'
      # '-~'
    }


    def _new_cmd(type, seq):
        def deco(func):
            type[seq] = func
        return deco


    call_unknown = None

    def call(self, name, *args):
        f = getattr(self, name, None)
        if f is not None:
            f(*args)
        elif self.call_unknown is not None:
            self.call_unknown(name, args=args)


    def process(self, input):
        input = iter(input)
        for c in input:
            if c >= 0x20:
                self.output(c)
            else:
                name = self.C0[c]
                self.call(name, (c,), input)


    def ESC(self, seq_in, input):
        seq = list(seq_in)
        if len(seq) == 1:
            n = input.next()
        else:
            n = seq[-1]
        code = array('B'))

        # Interpret the intermediate characters.
        while n < 0x30:
            if n < 0x20:
                # Embedded escape sequence; ESC, CAN, SUB end the current one.
                name = self.C0[n]
                if name == "ESC":
                    return self.call(name, (n,), input)
                if name in ("CAN", "SUB"):
                    return self.call(name, seq, input)
                else:
                    # The standards do not define what to do if any other
                    # control character is within the escape sequence.  Xterm
                    # just processes the escape recursively, so that's what we
                    # do here.
                    self.call(name, (n,), input)
            else:
                code.append(n)
            n = input.next()
        code.append(n)
        seq.extend(code)

        name = self.escapes.get(code.tostring())
        self.call(name, seq, input)


    # -------------------- Control String Functions --------------------

    def read_control_string(self, input, allow_BEL = False):
        """Read the control string and return the result as a list.  If the
        control string was cancelled with SUB, return None."""
        self.finished_reading_control_string = False
        out = []
        while True:
            n = input.next()
            if n >= 0x20:
                out.append(n)
            else:
                name = self.C0[n]
                seq = [n]
                if name == "SUB":
                    # cancel
                    self.call(name, seq, input)
                    return None
                elif allow_BEL and name == "BEL":
                    # finish
                    break
                elif name == "ESC":
                    p = input.next()
                    if p == ord('\\'):  # ST - string terminator
                        # finish
                        break
                    else:
                        # call the embedded escape sequence
                        seq.append(p)
                        self.call(name, seq, input)
                        # Cancel if we read another control string
                        if self.finished_reading_control_string:
                            return None
                else:
                    # call the embedded control
                    self.call(name, seq, input)
        self.finished_reading_control_string = True
        return out


    def APC(self, seq_in, input):
        self.read_control_string(input)

    def DCS(self, seq_in, input):
        self.read_control_string(input)

    def OSC(self, seq_in, input):
        self.read_control_string(input, True)

    def SOS(self, seq_in, input):
        self.read_control_string(input)

    def PM(self, seq_in, input):
        self.read_control_string(input)


    # --------------------                          --------------------


    def BS(self,c):
        self.move(0, -1)

    def HT(self,c):
        # TODO implement correctly
        self.move(0, 8-(self.pos[1]%8))

    def LF(self,c):
        self.move(1, 0)

    VT = LF
    FF = LF

    def CR(self,c):
        self.move(0, -self.pos[1])

    SI = ignore     # LS0
    SO = ignore     # LS1

    def NEL(self,c):
        self.CR(c)
        self.LF(c)

    # Will probably want to implement the following.
    IND = CR # TODO scrolling?
    HTS = ignore # TODO
    RI = ignore # TODO




def vt100_to_html(s):
    return Screen(s).output()


def process(infilename, outfilename = None):
    if outfilename is None:
        if infilename == '-':
            outfilename = '-'
        else:
            outfilename = infilename + EXT

    # Slurp the input
    if infilename == '-':
        infile = sys.stdin
    else:
        infile = open(infilename, 'rb')
    input = infile.read()
    if infile is not sys.stdin:
        infile.close()

    output = vt100_to_html(input)

    # Write all the output
    if outfilename == '-':
        outfile = sys.stdout
    else:
        outfile = open(outfilename, 'wb')
    outfile.write(output)
    if outfile is not sys.stdout:
        outfile.close()


def main(argv):
    if argv:
        for filename in sys.argv[1:]:
            main(filename)
    else:
        main('-')

if __name__ == "__main__":
    main(sys.argv[1:])
